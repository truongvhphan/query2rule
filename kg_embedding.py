# -*- coding: utf-8 -*-
"""cd3_embedding_datalog.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dT135oSKuFATND9tqJH7NYM4arUpAKKO
"""

# !pip install node2vec
import csv
import time
import numpy as np
import io

# path = 'data_tourism/tour_kg_v1.txt'
ent2id_path = 'data/YAGO13/entities.txt'
ent_id_path = 'data/YAGO13/entities_id.txt'
# ent_type_path = 'data_tourism/entities_types.txt'
tripleid_path = 'data/YAGO13/train.tsv'
rel2id_path = 'data/YAGO13/relations.txt'
rel_id_path = 'data/YAGO13/relation_id.txt'
# graph_path = 'data_tourism/train.tsv'
triples = []
ent2id = []
rel2id = []
ent_type = []

'''
with open(path, 'r', encoding='utf-8') as f:
  data = f.readlines()
  kg = open(graph_path, 'w', encoding='utf-8', newline='')
  w = csv.writer(kg, delimiter='\t')
  for line in data:
    # print(line)
    triplet = line.strip('\n').split('#')
    triples.append([triplet[0], triplet[1], triplet[2]])

    print(triplet)
    head, head_type = triplet[0].strip().split(':')
    tail, tail_type = triplet[2].strip().split(':')
    w.writerow([head, triplet[1].strip(), tail, head_type, tail_type])
    if head not in ent2id:
      ent2id.append(head)
    if tail not in ent2id:
      ent2id.append(tail)
    # if [head, head_type] not in ent_type:
    #   ent_type.append([head, head_type])
    # if [tail, tail_type] not in ent_type:
    #   ent_type.append([tail, tail_type])
    if triplet[1] not in rel2id:
      rel2id.append(triplet[1].strip())
  kg.close()
'''
'''
#write entities, relations, entities_types to files
with open(ent2id_path, 'r', encoding='utf-8') as e:
    data = e.readlines()
    i = 0
    f = open('data/YAGO13/entities_id.txt', 'w', encoding='utf-8')
    for k in data:
        f.write('{}\t{}\n'.format(i, k.strip('\n')))
        i += 1
    f.close()

with open(rel2id_path, 'r', encoding='utf-8') as e:
  data = e.readlines()
  i = 0
  f = open('data/YAGO13/relation_id.txt', 'w', encoding='utf-8')
  for k in data:
      f.write('{}\t{}\n'.format(i, k.strip('\n')))
      i += 1
'''
# with open(ent_type_path, 'w', encoding='utf-8') as e:
#
#   for k in ent_type:
#     e.write('{}\t{}\n'.format(k[0], k[1]))


ent2id = {}
rel2id = {}
id2ent = {}


with open(ent_id_path, 'r', encoding='utf-8') as f:
  data = f.readlines()
  for d in data:
    item = d.strip('\n').split('\t')
    ent2id[item[1]] = item[0]
    id2ent[item[0]] = item[1]

with open(rel_id_path, 'r', encoding='utf-8') as f:
  data = f.readlines()
  for d in data:
    item = d.strip('\n').split('\t')
    rel2id[item[1]] = item[0]

# with open(graph_path, 'r', encoding='utf-8') as f:
#   data = csv.reader(f, delimiter='\t')
#   k = open(tripleid_path, 'w', encoding='utf-8')
#
#   for t in data:
#     k.write('{}#{}#{}\n'.format(ent2id[t[0]], rel2id[t[1]], ent2id[t[2]]))
#   k.close()

import networkx as nx
from node2vec import Node2Vec


# Create a graph
G = nx.Graph()

with open(tripleid_path, 'r', encoding='utf-8') as f:
    data = csv.reader(f, delimiter='\t')
  # data = f.readlines()
  # Add edges to the graph
    for t in data:
        head, rel, tail = t[0], t[1], t[2]
        G.add_edge(head, tail, label=rel)

import pickle
# Save the knowledge graph to disk
with open('data/YAGO13/yago_kg/yago13_knowledge_graph.pkl', 'wb') as file:
    pickle.dump(G, file)

#load KG from disk
# import pickle
print("Load the KG from disk")
with open('data/YAGO13/yago_kg/yago13_knowledge_graph.pkl', 'rb') as file:
    G = pickle.load(file)

'''
#create subgraph with relations
relations = np.unique(list(nx.get_edge_attributes(G,'label').values()))

print(relations)
s = time.time()
for r in relations:
    tmp_g = nx.Graph()
    for k, v in nx.get_edge_attributes(G,'label').items():
        if v == r:
            # print(k, '----', v, '---', r)
            tmp_g.add_edge(k[0], k[1])
    # Save the knowledge graph to disk
    with open(f'data/YAGO13/yago_kg/yago13_knowledge_graph_{r}.pkl', 'wb') as file:
        pickle.dump(tmp_g, file)
    print(f'Saved knowledge graph {r}')

#################
#train node2vec and save models
degrees = G.degree()
NodeDegree=[]
NodeName=[]
# Print the node degrees
for node, degree in degrees:
    print(f"Node {node}: Degree {degree}")
    NodeDegree.append(degree)
    NodeName.append(node)
s = time.time()
'''
# Generate node embeddings using node2vec
node2vec = Node2Vec(G, dimensions=64, walk_length=30, num_walks=200, p=0.5, q=2, workers=1)
model = node2vec.fit(window=10, min_count=1, batch_words=4)

# Get the node embeddings
node_embeddings = model.wv
e = time.time()
print(f'Train time {e-s}')
# Print the embeddings for each node
# for node, embedding in zip(node_embeddings.index2entity, node_embeddings.vectors):
# for node, embedding in zip(node_embeddings.index_to_key, node_embeddings.vectors):
#     print(f"Node: {node}, Embedding: {embedding}")

# Save embeddings for later use
model.wv.save_word2vec_format('data/YAGO13/yago_kg/yago13_kg_node2vec.wv')

# Save model for later use
model.save('data/YAGO13/yago_kg/yago13_kg_node2vec.model')
s_t = time.time()
print(f'Saving time {s_t - e}')

''''

#load node2vec models
from gensim.models import Word2Vec
m = Word2Vec.load('data_tourism/kg_node2vec.model')
node_embeddings = m.wv

# Print the embeddings for each node
# for node, embedding in zip(node_embeddings.index2entity, node_embeddings.vectors):
for node, embedding in zip(node_embeddings.index_to_key, node_embeddings.vectors):
    print(f"Node: {node}, Embedding: {embedding}")

#create kdtree for each subgraph based on relations
import pickle
from scipy.spatial import KDTree

relations = np.unique(list(nx.get_edge_attributes(G, 'label').values())).tolist()
print(node_embeddings.vectors[node_embeddings.key_to_index['51']])

for r in relations:
  print(f"Load the KG {r} from disk")
  data = []
  with open(f'data_tourism/knowledge_graph_{r}.pkl', 'rb') as file:
      sub_graph = pickle.load(file)
  for node in sub_graph.nodes:
    # print(f'Node:{node}, Embedding: {node_embeddings.get_vector(node)}')
    embedding = node_embeddings.get_vector(node)
    data.append(embedding)
  kdtree = KDTree(data)
  with open(f'data_tourism/kd_tree_{r}.pkl', 'wb') as kdfile:
      pickle.dump(kdtree,kdfile)
print('DONE')

import pickle
import numpy as np
import networkx as nx

relations = np.unique(list(nx.get_edge_attributes(G, 'label').values())).tolist()
kdtree_subgraph = {}
for r in relations:
  with open(f'data_tourism/kd_tree_{r}.pkl', 'rb') as kdfile:
      kdtree_subgraph[r] = pickle.load(kdfile)
print('Loaded KD-Tree subgraph for each relation')

# Print the embeddings for each node
data=[]
datalabels=[]
query=[]
for node in node_embeddings.index_to_key:
    embedding = node_embeddings.get_vector(node)
    # print(f"Node: {node}, Embedding: {embedding}")
    # my_list = embedding.tolist()
    # embedding=my_list
    data.append(embedding)
    datalabels.append(node)
    query.append(embedding)
# KD TRee
from scipy.spatial import KDTree
kdtree = KDTree(data)
import pickle
# Save the kd-tree model to disk
with open('data_tourism/kdtree_model.pkl', 'wb') as file:
    pickle.dump(kdtree, file)
print("--- Perform range query----")
threshold = 1
# Perform range query for each query vector
i=0
for q_vector in query:
    # q_vector = query_vector]  # Convert query vector to a list with shape (1, 64)
    querylabel=datalabels[i]
    print("Query node label=",querylabel, id2ent[querylabel])
    i+=1
    indices = kdtree.query_ball_point(q_vector, threshold)
    print(indices)
    # result = [points[idx] for idx in indices]
    # print("Vectors within the threshold distance:")
    for index in indices:
      if datalabels[index] != querylabel:
        print(index, datalabels[index], id2ent[datalabels[index]])
    print("--------")

'''

'''
#load kd-tree model
import pickle
print("Load the model from disk")
with open('data_tourism/kdtree_model.pkl', 'rb') as file:
    kdtree = pickle.load(file)

#K-NN query
degrees = G.degree()
NodeDegree=[]
NodeName=[]
# Print the node degrees
for node, degree in degrees:
    print(f"Node {node}: Degree {degree}")
    NodeDegree.append(degree)
    NodeName.append(node)

# Print the embeddings for each node
data=[]
NodeLabel=[]
points=[]
for node in node_embeddings.index_to_key:
    embedding = node_embeddings.get_vector(node)
    # print(f"Node: {node}, Embedding: {embedding}")
    data.append(tuple(embedding))
    points.append(tuple(embedding))
    NodeLabel.append(node)


# Print the nearest neighbors for each query point
print("Print the nearest neighbors for each query point")
for i in range(len(points)):
    print("\n=========================================")
    query_point = points[i]
    query_point_label=NodeLabel[i]
    print("Node Label of this point",query_point_label, id2ent[query_point_label])
    vt=NodeName.index(query_point_label)
    print("Degree:",NodeDegree[vt])
    k = NodeDegree[vt]+1 # Number of nearest neighbors to retrieve
    distances, indices = kdtree.query(points, k=k)
    nearest_neighbors_indices = indices[i]
    nearest_neighbors_distances = distances[i]
    print(f"Nearest neighbors for point {query_point}:")
    print(f"Nearest neighbors for point index {nearest_neighbors_indices}:")

    for j in range(len(nearest_neighbors_indices)):
        neighbor_index = nearest_neighbors_indices[j]
        neighbor_distance = nearest_neighbors_distances[j]
        neighbor_point = data[neighbor_index]
        neighbor_point_label=NodeLabel[neighbor_index]
        if neighbor_point_label != query_point_label:
          # print("vi tri:",neighbor_point)
          print("Node label:",neighbor_point_label, id2ent[neighbor_point_label])
          print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
          print(f"Neighbor index {j + 1}: Point index {neighbor_index}")
    print()

#K-NN query
degrees = G.degree()
NodeDegree=[]
NodeName=[]
# Print the node degrees
for node, degree in degrees:
    # print(f"Node {node}: Degree {degree}")
    NodeDegree.append(degree)
    NodeName.append(node)

# Print the embeddings for each node
data=[]
NodeLabel=[]
points=[]
for node in node_embeddings.index_to_key:
    embedding = node_embeddings.get_vector(node)
    # print(f"Node: {node}, Embedding: {embedding}")
    data.append(tuple(embedding))
    points.append(tuple(embedding))
    NodeLabel.append(node)

print(NodeLabel)

# Print the nearest neighbors for each query point
print("Print the nearest neighbors for each query point")

print("\n=========================================")
query_point = points[0]
query_point_label=NodeLabel[0]
print("Node Label of this point",query_point_label, id2ent[query_point_label])
vt=NodeName.index(query_point_label)
print("Degree:",NodeDegree[vt])
k = NodeDegree[vt]+1 # Number of nearest neighbors to retrieve
distances, indices = kdtree.query(points, k=k)
nearest_neighbors_indices = indices[0]
nearest_neighbors_distances = distances[0]
print(f"Nearest neighbors for point {query_point}:")
print(f"Nearest neighbors for point index {nearest_neighbors_indices}:")

for j in range(1, len(nearest_neighbors_indices)):
    neighbor_index = nearest_neighbors_indices[j]
    neighbor_distance = nearest_neighbors_distances[j]
    neighbor_point = data[neighbor_index]
    neighbor_point_label=NodeLabel[neighbor_index]
    if neighbor_point_label != query_point_label:
      # print("vi tri:",neighbor_point)
      print("Node label:",neighbor_point_label, id2ent[neighbor_point_label])
      # print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
      print(f"Neighbor index {j + 1}: Point index {neighbor_index}")

      print('========Level 2===============')
      query_point_1 = points[neighbor_index]
      query_point_label_1=NodeLabel[neighbor_index]
      vt_1=NodeName.index(query_point_label_1)
      print("\tDegree:",NodeDegree[vt_1])
      k_1 = NodeDegree[vt_1]+1 # Number of nearest neighbors to retrieve
      distances_1, indices_1 = kdtree.query(points, k=k_1)
      nearest_neighbors_indices_1 = indices_1[neighbor_index]
      nearest_neighbors_distances_1 = distances_1[neighbor_index]
      # print(f"\tNearest neighbors for point {query_point_1}:")
      print(f"\tNearest neighbors for point index {nearest_neighbors_indices_1}:")

      for l in range(1, len(nearest_neighbors_indices_1)):
        neighbor_index_1 = nearest_neighbors_indices_1[l]
        neighbor_distance_1 = nearest_neighbors_distances_1[l]
        neighbor_point_1 = data[neighbor_index_1]
        neighbor_point_label_1 = NodeLabel[neighbor_index_1]
        if neighbor_point_label_1 != query_point_label_1:
          # print("vi tri:",neighbor_point)
          print("Node label:",neighbor_point_label_1, id2ent[neighbor_point_label_1])
          # print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
          print(f"Neighbor index {l + 1}: Point index {neighbor_index_1}")

          print('========Level 3===============')
          query_point_2 = points[neighbor_index_1]
          query_point_label_2=NodeLabel[neighbor_index_1]
          vt_2=NodeName.index(query_point_label_2)
          print("\t\tDegree:", NodeDegree[vt_2])
          k_2 = NodeDegree[vt_2]+1 # Number of nearest neighbors to retrieve
          distances_2, indices_2 = kdtree.query(points, k=k_2)
          nearest_neighbors_indices_2 = indices_2[neighbor_index]
          nearest_neighbors_distances_2 = distances_2[neighbor_index]
          # print(f"\tNearest neighbors for point {query_point_1}:")
          print(f"\t\tNearest neighbors for point index {nearest_neighbors_indices_2}:")

          for m in range(1, len(nearest_neighbors_indices_2)):
            neighbor_index_2 = nearest_neighbors_indices_2[m]
            neighbor_distance_2 = nearest_neighbors_distances_2[m]
            neighbor_point_2 = data[neighbor_index_2]
            neighbor_point_label_2 = NodeLabel[neighbor_index_2]
            if neighbor_point_label_2 != query_point_label_2:
              # print("vi tri:",neighbor_point)
              print("\t\tNode label:",neighbor_point_label_2, id2ent[neighbor_point_label_2])
              # print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
              print(f"\t\tNeighbor index {m + 1}: Point index {neighbor_index_2}")

# print()
'''


'''
def init_data_for_multihop(KG):
  degrees = KG.degree()
  NodeDegree=[]
  NodeName=[]
  # Print the node degrees
  for node, degree in degrees:
      # print(f"Node {node}: Degree {degree}")
      NodeDegree.append(degree)
      NodeName.append(node)

  # Print the embeddings for each node
  data=[]
  NodeLabel=[]
  points=[]
  for node in KG.nodes:
    embedding = node_embeddings.get_vector(node)
    # print(f"Node: {node}, Embedding: {embedding}")
    data.append(tuple(embedding))
    points.append(tuple(embedding))
    NodeLabel.append(node)
  return NodeDegree, NodeName, data, NodeLabel, points

import pickle
def multihop_all(relations=['0','1']):

  node_hop = {}
  for r in relations:
    with open(f'data_tourism/knowledge_graph_{r}.pkl', 'rb') as f:
      kg = pickle.load(f)
    NodeDegree, NodeName, data, NodeLabel, points = init_data_for_multihop(kg)

    kd_tree = kdtree_subgraph[r]

    for node in kg.nodes:
      print(f'Start Node:{id2ent[node]}')
      pos = NodeName.index(node)
      vt = NodeLabel.index(node)
      query_point = points[vt]
      print("Degree:",NodeDegree[pos])
      k = NodeDegree[pos] + 1 # Number of nearest neighbors to retrieve
      distances, indices = kd_tree.query(query_point, k=k)
      nearest_neighbors_indices = indices
      nearest_neighbors_distances = distances
      print(f"Nearest neighbors for point {query_point}:")
      print(f"Nearest neighbors for point index {nearest_neighbors_indices}:")


      for j in range(len(nearest_neighbors_indices)):
          tmp = []
          neighbor_index = nearest_neighbors_indices[j]
          neighbor_distance = nearest_neighbors_distances[j]
          neighbor_point = data[neighbor_index]
          neighbor_point_label=NodeLabel[neighbor_index]
          tmp.append(neighbor_point_label)

          # print("vi tri:",neighbor_point)
          print("Node label:",neighbor_point_label, id2ent[neighbor_point_label])
          print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
          print(f"Neighbor index {j + 1}: Point index {neighbor_index}")

      if node not in node_hop:
        node_hop[node] = []
        node_hop[node].append(tmp)
      else:
        node_hop[node].append(tmp)
      print()

  for k, v in node_hop.items():
    if len(v) > 1:
      print(f'Node {k} and NN {v}')


multihop_all()

import pickle
def multihop(start_node, end_node, relations=['0','1']):

  embedding = node_embeddings.get_vector(start_node)
  for r in relations:
    with open(f'data_tourism/knowledge_graph_{r}.pkl', 'rb') as f:
      kg = pickle.load(f)
    NodeDegree, NodeName, data, NodeLabel, points = init_data_for_multihop(kg)

    kd_tree = kdtree_subgraph[r]


    print(f'Start Node:{id2ent[start_node]}')
    pos = NodeName.index(start_node)
    vt = NodeLabel.index(start_node)
    query_point = points[vt]
    print("Degree:",NodeDegree[pos])
    k = NodeDegree[pos]+1 # Number of nearest neighbors to retrieve
    distances, indices = kd_tree.query(query_point, k=k)
    nearest_neighbors_indices = indices
    nearest_neighbors_distances = distances
    print(f"Nearest neighbors for point {query_point}:")
    print(f"Nearest neighbors for point index {nearest_neighbors_indices}:")


    for j in range(1, len(nearest_neighbors_indices)):
        neighbor_index = nearest_neighbors_indices[j]
        neighbor_distance = nearest_neighbors_distances[j]
        neighbor_point = data[neighbor_index]
        neighbor_point_label=NodeLabel[neighbor_index]
        if neighbor_point_label != start_node:
          # print("vi tri:",neighbor_point)
          print("Node label:",neighbor_point_label, id2ent[neighbor_point_label])
          print(f"Neighbor {j + 1}: Point {neighbor_point}, Distance: {neighbor_distance}")
          print(f"Neighbor index {j + 1}: Point index {neighbor_index}")
    print()
    start_node = neighbor_point_label


multihop('186', '60')
'''